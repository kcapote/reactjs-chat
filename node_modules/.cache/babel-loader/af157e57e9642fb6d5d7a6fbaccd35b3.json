{"ast":null,"code":"import _defineProperty from \"/home/alaya/workspace/lab/reactjs-chat/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { SAVE_COMMENT, LIST_COMMENTS } from './types';\nimport firebase from '../components/db/firestore';\nconst db = firebase.firestore();\nexport const saveComment = (collection, comment) => async dispatch => {\n  //if(true) return;\n  if (!comment) return;\n  const ref = db.collection(collection);\n  const obj = {};\n  let out = {};\n\n  if (collection == 'chats') {\n    obj = {\n      userId: db.doc(\"/users/\".concat(comment.userId)),\n      message: comment.message,\n      roomId: db.doc(\"/rooms/\".concat(comment.roomId))\n    };\n  } else {\n    const chatKey = [this.state.user2.id, this.state.user1].sort().join();\n    obj = {\n      userId: db.doc(\"/users/\".concat(comment.userId)),\n      message: comment.message,\n      roomId: db.doc(\"/rooms/\".concat(comment.roomId)),\n      chatKey\n    };\n  }\n\n  try {\n    out = await ref.add(obj);\n  } catch (err) {\n    console.log('comment error', err);\n    out = err;\n  } finally {\n    dispatch({\n      type: SAVE_COMMENT,\n      payload: out\n    });\n  }\n};\nexport const getComments = roomId => async dispatch => {\n  const refRoomId = db.collection('rooms').doc(roomId);\n  let chats = [];\n\n  try {\n    let ref = db.collection('chats').where(\"roomId\", \"==\", refRoomId).orderBy(\"createdAt\", \"desc\").limit(10);\n    let observer = await ref.onSnapshot(snap => snap.docs.map(async doc => {\n      let user = await doc.data().userId.get();\n      let chat = {\n        id: doc.id,\n        message: doc.data().message,\n        user: _objectSpread({\n          id: user.id\n        }, user.data())\n      };\n      chats.push(chat);\n    }));\n  } catch (err) {\n    console.log('getComments', err);\n    chats = err;\n  } finally {\n    let chatsTemp = JSON.parse(JSON.stringify(chats));\n    console.log('finally', chats);\n    console.log('finally2', chatsTemp); //chats=[];\n\n    dispatch({\n      type: LIST_COMMENTS,\n      payload: chats\n    });\n  } //\n  //  await ref.onSnapshot((data)=>{\n  //            chats=[];\n  //            data.docs.forEach ( async c => {\n  //              let data = c.data();\n  //              let r = data.userId.get();\n  //              let user = await data.userId.get();                 \n  //              //let room = await data.roomId.get(); \n  //              let d = {\n  //                key: c.id,\n  //                message: data.message, \n  //                user: { id: user.id, ...user.data() },\n  //               /// room: { id: room.id, ...room.data() }\n  //              }\n  //              chats.push(d);\n  //            });\n  //            console.log('reverse', chats.reverse());\n  //            setState({... state,\n  //                          chats: chats.reverse(),\n  //                          isRomm: true\n  //                          });\n  //   });\n\n};","map":{"version":3,"sources":["/home/alaya/workspace/lab/reactjs-chat/src/actions/chatActions.js"],"names":["SAVE_COMMENT","LIST_COMMENTS","firebase","db","firestore","saveComment","collection","comment","dispatch","ref","obj","out","userId","doc","message","roomId","chatKey","state","user2","id","user1","sort","join","add","err","console","log","type","payload","getComments","refRoomId","chats","where","orderBy","limit","observer","onSnapshot","snap","docs","map","user","data","get","chat","push","chatsTemp","JSON","parse","stringify"],"mappings":";;;;;;AAAA,SAASA,YAAT,EAAuBC,aAAvB,QAA4C,SAA5C;AACA,OAAOC,QAAP,MAAqB,4BAArB;AAGA,MAAMC,EAAE,GAAGD,QAAQ,CAACE,SAAT,EAAX;AAGA,OAAO,MAAMC,WAAW,GAAG,CAACC,UAAD,EAAaC,OAAb,KAAyB,MAAMC,QAAN,IAAkB;AAGlE;AACA,MAAG,CAACD,OAAJ,EAAa;AAGb,QAAME,GAAG,GAAGN,EAAE,CAACG,UAAH,CAAcA,UAAd,CAAZ;AACA,QAAMI,GAAG,GAAG,EAAZ;AACA,MAAIC,GAAG,GAAG,EAAV;;AAEA,MAAKL,UAAU,IAAI,OAAnB,EAA6B;AACzBI,IAAAA,GAAG,GAAG;AACJE,MAAAA,MAAM,EAAGT,EAAE,CAACU,GAAH,kBAAiBN,OAAO,CAACK,MAAzB,EADL;AAEJE,MAAAA,OAAO,EAAEP,OAAO,CAACO,OAFb;AAGJC,MAAAA,MAAM,EAAGZ,EAAE,CAACU,GAAH,kBAAiBN,OAAO,CAACQ,MAAzB;AAHL,KAAN;AAKH,GAND,MAMO;AACJ,UAAMC,OAAO,GAAG,CAAC,KAAKC,KAAL,CAAWC,KAAX,CAAiBC,EAAlB,EAAqB,KAAKF,KAAL,CAAWG,KAAhC,EAAuCC,IAAvC,GAA8CC,IAA9C,EAAhB;AACCZ,IAAAA,GAAG,GAAG;AACJE,MAAAA,MAAM,EAAGT,EAAE,CAACU,GAAH,kBAAiBN,OAAO,CAACK,MAAzB,EADL;AAEJE,MAAAA,OAAO,EAAEP,OAAO,CAACO,OAFb;AAGJC,MAAAA,MAAM,EAAGZ,EAAE,CAACU,GAAH,kBAAiBN,OAAO,CAACQ,MAAzB,EAHL;AAIJC,MAAAA;AAJI,KAAN;AAMH;;AAED,MAAI;AACFL,IAAAA,GAAG,GAAG,MAAMF,GAAG,CAACc,GAAJ,CAAQb,GAAR,CAAZ;AACD,GAFD,CAEE,OAAOc,GAAP,EAAa;AACbC,IAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA4BF,GAA5B;AACAb,IAAAA,GAAG,GAAGa,GAAN;AACD,GALD,SAKU;AACRhB,IAAAA,QAAQ,CAAC;AACPmB,MAAAA,IAAI,EAAE3B,YADC;AAEP4B,MAAAA,OAAO,EAAEjB;AAFF,KAAD,CAAR;AAID;AAEJ,CAvCM;AA0CP,OAAO,MAAMkB,WAAW,GAAId,MAAD,IAAY,MAAMP,QAAN,IAAkB;AAEvD,QAAMsB,SAAS,GAAG3B,EAAE,CAACG,UAAH,CAAc,OAAd,EAAuBO,GAAvB,CAA2BE,MAA3B,CAAlB;AACD,MAAIgB,KAAK,GAAC,EAAV;;AAEC,MAAG;AACD,QAAItB,GAAG,GAAGN,EAAE,CAACG,UAAH,CAAc,OAAd,EACG0B,KADH,CACS,QADT,EACkB,IADlB,EACuBF,SADvB,EAEGG,OAFH,CAEW,WAFX,EAEwB,MAFxB,EAGGC,KAHH,CAGS,EAHT,CAAV;AAIA,QAAIC,QAAQ,GAAG,MAAM1B,GAAG,CAAC2B,UAAJ,CAAiBC,IAAI,IAExCA,IAAI,CAACC,IAAL,CAAUC,GAAV,CAAe,MAAM1B,GAAN,IAAa;AAC1B,UAAI2B,IAAI,GAAG,MAAM3B,GAAG,CAAC4B,IAAJ,GAAW7B,MAAX,CAAkB8B,GAAlB,EAAjB;AACA,UAAIC,IAAI,GAAG;AACPxB,QAAAA,EAAE,EAAEN,GAAG,CAACM,EADD;AAEPL,QAAAA,OAAO,EAAED,GAAG,CAAC4B,IAAJ,GAAW3B,OAFb;AAGP0B,QAAAA,IAAI;AAAGrB,UAAAA,EAAE,EAAEqB,IAAI,CAACrB;AAAZ,WAAmBqB,IAAI,CAACC,IAAL,EAAnB;AAHG,OAAX;AAKAV,MAAAA,KAAK,CAACa,IAAN,CAAWD,IAAX;AAED,KATD,CAFmB,CAArB;AAgBD,GArBD,CAqBE,OAAQnB,GAAR,EAAa;AACbC,IAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BF,GAA3B;AACAO,IAAAA,KAAK,GAAGP,GAAR;AAED,GAzBD,SAyBS;AACP,QAAIqB,SAAS,GAAIC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,SAAL,CAAejB,KAAf,CAAX,CAAjB;AACAN,IAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBK,KAAvB;AACAN,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBmB,SAAxB,EAHO,CAIP;;AACArC,IAAAA,QAAQ,CAAC;AACPmB,MAAAA,IAAI,EAAE1B,aADC;AAEP2B,MAAAA,OAAO,EAAEG;AAFF,KAAD,CAAR;AAID,GAvCsD,CAwCzD;AACC;AACC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AACA,CA9DM","sourcesContent":["import { SAVE_COMMENT, LIST_COMMENTS } from './types';\nimport firebase from '../components/db/firestore';\n\n\nconst db = firebase.firestore();\n\n\nexport const saveComment = (collection, comment) => async dispatch => {\n\n    \n    //if(true) return;\n    if(!comment) return;\n\n\n    const ref = db.collection(collection);\n    const obj = {};\n    let out = {};\n\n    if ( collection == 'chats' ) {\n        obj = {\n          userId:  db.doc(`/users/${comment.userId}`),\n          message: comment.message,\n          roomId:  db.doc(`/rooms/${comment.roomId}`)\n        }\n    } else {\n       const chatKey = [this.state.user2.id,this.state.user1].sort().join();\n        obj = {\n          userId:  db.doc(`/users/${comment.userId}`),\n          message: comment.message,\n          roomId:  db.doc(`/rooms/${comment.roomId}`),\n          chatKey\n        }\n    } \n\n    try {\n      out = await ref.add(obj);\n    } catch( err ) {      \n      console.log('comment error',err);\n      out = err; \n    } finally {\n      dispatch({\n        type: SAVE_COMMENT,\n        payload: out\n      });\n    }\n\n} \n\n\nexport const getComments = (roomId) => async dispatch => {\n\n  const refRoomId = db.collection('rooms').doc(roomId);\n\tlet chats=[];\n\t\n  try{\n    let ref = db.collection('chats')\n                .where(\"roomId\",\"==\",refRoomId)\n                .orderBy(\"createdAt\", \"desc\")\n                .limit(10);\n    let observer = await ref.onSnapshot(  snap=>(\n            \n      snap.docs.map( async doc => {\n        let user = await doc.data().userId.get()  \n        let chat = {\n            id: doc.id,\n            message: doc.data().message,\n            user: {id: user.id, ...user.data() }\n        }\n        chats.push(chat);\n \n      })\n    ));  \n\n  \n\n  } catch ( err ){\n    console.log('getComments', err);\n    chats = err;\n\n  } finally{\n    let chatsTemp =  JSON.parse(JSON.stringify(chats)) ;\n    console.log('finally', chats);\n    console.log('finally2', chatsTemp);\n    //chats=[];\n    dispatch({\n      type: LIST_COMMENTS,\n      payload: chats\n    })\n  }\n//\n\t//  await ref.onSnapshot((data)=>{\n  //            chats=[];\n  //            data.docs.forEach ( async c => {\n  //              let data = c.data();\n  //              let r = data.userId.get();\n  //              let user = await data.userId.get();                 \n  //              //let room = await data.roomId.get(); \n  //              let d = {\n  //                key: c.id,\n  //                message: data.message, \n  //                user: { id: user.id, ...user.data() },\n  //               /// room: { id: room.id, ...room.data() }\n  //              }\n  //              chats.push(d);\n  //            });\n  //            console.log('reverse', chats.reverse());\n  //            setState({... state,\n  //                          chats: chats.reverse(),\n  //                          isRomm: true\n  //                          });\n\t//   });\n}"]},"metadata":{},"sourceType":"module"}